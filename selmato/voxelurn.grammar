# domain specific grammar for voxelurn

(include dal.grammar)

# domain specific actions:
(def @put put)
(def @base base)
(def @add add)
(def @move move)
(def @turn turn)
(def @stop stop)

# syntactic sugar
(def @veryx veryx)

# typed lambdas
# Action a, ItemSet i, ValueSet v, Rel r, Direction d, Color c, Number n
# Rule.defaultIsFloating should be false

# utilities
(rule $Action (base $Number $Number) (lambda x (lambda y (: @base (var x) (var y)))) (anchored 1))
(rule $Action (noop) (ConstantFn (: noop)) (anchored 1))

(rule $Set (origin) (ConstantFn (call origin)) (anchored 1))

# primitive actions
(rule $Action (add $Color) (lambda c (: @add (var c) here)) (anchored 1))
(rule $Action (add $Color $Direction) (lambda c (lambda d (: @add (var c) (var d)))) (anchored 1))
(rule $Action (move $Direction) (lambda d (: @move (var d))) (anchored 1)) #simple move instruction, just takes dir-argument
(rule $Action (move $Direction $Number $Extent) (lambda x ( lambda y ( lambda z (: @move (var x) (var y) (var z))))) (anchored 1))
(rule $Action (move to $Location) (lambda l (: @move (var l))) (anchored 1))
(rule $Action (move to the $Location) (lambda l (: @move (var l))) (anchored 1))
(rule $Action (move into the $Location) (lambda l (: @move (var l))) (anchored 1))
(rule $Action (go $Direction) (lambda d (: @move (var d))) (anchored 1))
(rule $Action (go $Direction $Number $Extent) (lambda x ( lambda y ( lambda z (: @move (var x) (var y) (var z))))) (anchored 1))
(rule $Action (go to the $Location) (lambda l (: @move (var l))) (anchored 1))
(rule $Action (go into the $Location) (lambda l (: @move (var l))) (anchored 1))
(rule $Action (navigate $Direction) (lambda d (: @move (var d))) (anchored 1))
(rule $Action (navigate $Direction $Number $Extent) (lambda x ( lambda y ( lambda z (: @move (var x) (var y) (var z))))) (anchored 1))
(rule $Action (navigate to the $Location) (lambda l (: @move (var l))) (anchored 1))
(rule $Action (navigate into the $Location) (lambda l (: @move (var l))) (anchored 1))
(rule $Action (turn $Direction) (lambda d (: @turn (var d))) (anchored 1))
(rule $Action (turn $Direction $Number $Extent) (lambda x ( lambda y ( lambda z (: @turn (var x) (var y) (var z))))) (anchored 1))
(rule $Action (spin $Direction) (lambda d (: @turn (var d))) (anchored 1))
(rule $Action (spin $Direction $Number $Extent) (lambda x ( lambda y ( lambda z (: @turn (var x) (var y) (var z))))) (anchored 1))
(rule $Action ($Name stop) (lambda x (: @stop (var x))) (anchored 1)) #simple stop instruction, just takes name-argument

# primitive actions with arguments

# cube to cube relations
(rule $Set ($Direction of $Set) (lambda d (lambda s
			   (call adj (var d) (var s)))) (anchored 1))
(rule $Set ($Extreme of $Set) (lambda e (lambda s
			   (call @veryx (var e) (var s)))) (anchored 1))
(rule $Set ($Direction) (lambda d
			   (call adj (var d))) (anchored 1))
(rule $Set ($Extreme) (lambda e
			   (call @veryx (var e))) (anchored 1))

(for @dir (top bottom left right front back forward forwards backward backwards up down)
  (rule $Direction (@dir) @dir (anchored 1))
)

(for @loc (desk kitchen hallway lab door)
  (rule $Location (@loc) @loc (anchored 1))
)


(rule $Set ($Name) (lambda x
			   (call n (var x))) (anchored 1))

(for @name (robot all)
  (rule $Name (@name) @name (anchored 1))
)



(rule $Extreme (very $Direction) (IdentityFn) (anchored 1))

(for @rel (col row height color name age)
  (rule $Rel (@rel) (ConstantFn @rel) (anchored 1))
)

(rule $ValueSet ($Color) (IdentityFn) (anchored 1))
(rule $ValueSet ($Number) (IdentityFn) (anchored 1))

(rule $ValueSet ($Extent) (IdentityFn) (anchored 1))
(rule $ValueSet ($Location) (IdentityFn) (anchored 1))


# set the range via NumberFn options

(rule $Number ($TOKEN) (NumberFn) (anchored 1))
(rule $Color ($TOKEN) (SimpleLexiconFn (type color)) (anchored 1))
(rule $Extent ($TOKEN) (SimpleLexiconFn (type extent)) (anchored 1))
(rule $Location ($TOKEN) (SimpleLexiconFn (type location)) (anchored 1))

####### domain specific floating rules
# red means has color red
# (rule $Sets ($Color) (lambda c (color (var c))))

# various actions can be performed
# (rule $Action ($Color) (lambda c (: @add (var c) here)))
# (rule $Action ($Color $Direction) (lambda c (lambda d (: @add (var c) (var d)))))
# (rule $Action ($Direction) (lambda d (: @move (var d))))

# (rule $Set ($Direction $Sets) (lambda d (lambda s
#			   (call adj (var d) (var s)))))
# (rule $Set ($Extreme $Sets) (lambda e (lambda s
#			   (call @veryx (var e) (var s)))))
# (rule $Set ($Direction) (lambda d
#			   (call adj (var d))))
# (rule $Set ($Extreme) (lambda e
#			   (call @veryx (var e))))
